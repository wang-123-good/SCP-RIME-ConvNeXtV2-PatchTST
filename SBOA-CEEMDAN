

import os, random, warnings, math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PyEMD import CEEMDAN
from sklearn.metrics import mean_squared_error

warnings.filterwarnings("ignore")


def seed_everything(seed=42):
    random.seed(seed)
    np.random.seed(seed)
seed_everything()


CSV_PATH = "Q1.csv"       
df         = pd.read_csv(CSV_PATH, parse_dates=["datetime"])
ts         = df["nat_demand"].values
timestamps = df["datetime"]


search_space = {
    "ensemble_size": [100, 150, 200, 250, 300, 350],
    "noise_strength": [0.1, 0.125, 0.15, 0.175, 0.2, 0.25, 0.3],
    "max_imf":        [6, 7, 8, 9, 10, 11, 12]
}


def norm(v, lst): idx = lst.index(v);                return idx / (len(lst)-1)
def denorm(v, lst): idx = int(round(v*(len(lst)-1))); return lst[max(0, min(idx, len(lst)-1))]


def evaluate(params):
    try:
        c = CEEMDAN()
        c.num_ensembles = params["ensemble_size"]
        c.noise_width   = params["noise_strength"]
        imfs = np.array(c(ts, max_imf=params["max_imf"]))       
        if imfs.size == 0: return float("inf"), None
        recon = np.sum(imfs[:-1], axis=0)                     
        rmse  = math.sqrt(mean_squared_error(ts[:len(recon)], recon))
        return rmse, imfs
    except Exception:
        return float("inf"), None


pop_size, max_iter = 15, 30         
elite_num          = 2              


def init_population():
    return [
        {k: random.random() for k in search_space}  
        for _ in range(pop_size)
    ]


def sboa_optimize():
    pop = init_population()
    best_score = float("inf")
    best_indiv = None
    best_imfs = None

    for t in range(max_iter):
        alpha_t = 0.9 - 0.5 * (t / max_iter)  
        beta_t = 0.5 * (1 - t / max_iter)  

        scores, decoded = [], []
        for indiv in pop:
            params = {k: denorm(indiv[k], search_space[k]) for k in indiv}
            score, imfs = evaluate(params)

            if imfs is None:
                print(f"[⚠️  Invalid IMFs] Params: {params}")
                score = float("inf")

            scores.append(score)
            decoded.append(params)

            if score < best_score and imfs is not None:
                best_score = score
                best_indiv = indiv.copy()
                best_imfs = imfs

       
        if best_indiv is None:
            print(f"❌ Iter {t + 1}: No valid individuals found, skipping.")
            continue

       
        elite_idx = np.argsort(scores)[:elite_num]
        elites = [pop[i].copy() for i in elite_idx]

        
        new_pop = []
        for i in range(pop_size):
            indiv = pop[i]
            new = {}
            for k in indiv:
                if random.random() < alpha_t:
                    new[k] = indiv[k] + beta_t * (best_indiv[k] - indiv[k]) * random.uniform(-1, 1)
                else:
                    theta = random.uniform(0, 2 * np.pi)
                    new[k] = indiv[k] + beta_t * math.sin(theta)
                new[k] = min(max(new[k], 0), 1)
            new_pop.append(new)

        
        new_pop[:elite_num] = elites
        pop = new_pop

        print(
            f"✅ Iter {t + 1}/{max_iter} | Best RMSE (IMF-only): {best_score:.4f} | Best params: {decoded[np.argmin(scores)]}")

    
    if best_indiv is None:
        raise RuntimeError("Optimization failed: no valid individuals found in all iterations.")

    best_params = {k: denorm(best_indiv[k], search_space[k]) for k in best_indiv}
    return best_params, best_imfs


best_params, best_imfs = sboa_optimize()
n_imf = best_imfs.shape[0]                             


exclude_cols = ["nat_demand"]
feature_cols = [c for c in df.columns if c not in exclude_cols + ["datetime"]]
raw_feat     = df[feature_cols]
raw_feat.index = df["datetime"]


out_dir = "CSV_Components"
os.makedirs(out_dir, exist_ok=True)

for i in range(n_imf):
    name      = "Residue" if i == n_imf-1 else f"IMF_{i+1}"
    series    = pd.Series(best_imfs[i], index=timestamps[:len(best_imfs[i])], name=name)
    comp_df   = pd.concat([series, raw_feat.loc[series.index]], axis=1).dropna()
    comp_df.to_csv(os.path.join(out_dir, f"{name}_Features.csv"))
    print(f"✔ Saved {name}_Features.csv | shape={comp_df.shape}")

# ------------11. 可视化分解 ------------
plt.figure(figsize=(12, 2*(n_imf+1)))
plt.subplot(n_imf+1,1,1); plt.plot(timestamps, ts, color='black'); plt.title("Original TSD")

for i in range(n_imf):
    plt.subplot(n_imf+1,1,i+2)
    plt.plot(timestamps[:len(best_imfs[i])], best_imfs[i])
    plt.title("Residue" if i==n_imf-1 else f"IMF {i+1}")
    plt.tight_layout()

os.makedirs("Figures", exist_ok=True)
plt.savefig("Figures/CEEMDAN_Decomposition.png", dpi=300)
print(f"\n✅ Best params: {best_params} | Components & figure saved.")
